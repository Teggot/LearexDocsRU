Процесс установки
=================

1. Скачайте последнюю версию отсюда https://github.com/Teggot/LearexDocs/releases.
2. Это архив так что просто запустите его в любой пустой папке.
3. Добавьте путь к learex.exe в PATH.
4. Создайте LEAREXHOME и присвойте ей путь к корневой папке learex.

Быстрый гайд
============

Переменные
^^^^^^^^^^

Вам нужно вникнуться в специфический синтаксис::

    10 >> age;
    # age = 10
    5. >> double value;
    # value = 5.0

Здесь я создал 2 переменные "age" и "value".
В данном случае "age" динамическая, это значит что вы можете менять и значение и тип, и "value" создана со статическим типом "double" - вы можете менять только значение, но не тип.

Также вы можете использовать "<<", но нельзя делать вложения. Например::

    age << 10;
    # age = 10
    return << age;

Сложный пример 
^^^^^^^^^^^^^^

Вот как это выглядит.
Не интересно скажете Вы? У меня есть пример гораздо сложнее::

    example(10), 10 >> example{1}, var, example(10) >> sum{3} >> age >> out;

Здесь есть немного функций и слегка сложная конструкция, но Вы разберетесь в этом очень и очень быстро.

Импорт
^^^^^^

Вот примеры импортов модулей::

    import IO

    # Импрот всего модуля

    from IO{
        import func out(int val):void
    }

    # Импорт опреденных функций из модуля

    import func printf(string a, b):int32

    # Импорт встроенных функций

Функции
^^^^^^^

Вы также можете создавать функции::

    func calc(int a, int b){
        a + b >> return;
    }

    func example(double a):double{
        a*1.5 >> return;
    }

Здесь 2 функции.
Тут есть очень странная вещь после "func example(double a)". ":double" означет тип возврата. По умолчанию каждая функция возвращает "void" и если вы не указали тип возврата, функция сама определит его сам по себе. (Обьявление типа возврата важно при рекурсии).

Усложненное "складывание"
^^^^^^^^^^^^^^^^^^^^^^^^^

А вот и тот самый интересный синтаксис.

Вы можете "складывать" значения в функции::

    10, 5 >> calc{2} >> int some;
    # some = 15

Что такое "{2}" я обьясню позже.

Сейчас я обьясню как работает "," в данном контексте::

    10, 20 >> int a, b;
    # a = 10
    # b = 20

Тут Вы можете увидеть что первый елемент слева ушел в первую переменную справа, 2-ая в 2-ую и т.д.

Давайте посмотрим на этот пример::

    10, 20 >> calc{2} >> out; # out is imported from IO
    # 30

Здесь "{2}" сделано для функции "перегрузки". Это означет, что когда вы вызываете функцию в контексте ">>" компилятор не знает какое количество аргументов Вы отправляете в функцию. Так вот, "{2}" означет что компилятор будет искать функцию с 2-мя параметрами.

Кстати, если Вы не указали "{}", то компилятор будет искать функцю с одним аргументом.
    
Еще можно вызывать функцию вот так::

    calc(10, 20) >> out;
    # 30

Разширение ">>" контекста
^^^^^^^^^^^^^^^^^^^^^^^^^

Also you can add new arguments to your "put" context e.g.
Вы можете добавлять аргументы с каждым ">>", например::

    10, 20 >> calc{2}, calc(10, 20) >> calc{2} >> out;
    # 60

Обращение к типу
^^^^^^^^^^^^^^^^

Вы можете обащать переменные к типу::

    age|double >> out;
    # age выведется с типом double;


Условия
^^^^^^^

To run code ahead you should import IO lib (as i have mentioned before)
Вы должны импортнуть модуль IO(как я показывал до этого).

::

    if (10 == 10){
        10 >> out;
    }else if 20 == 20{
        20 >> out;
    }else{
        30 >> out;
    }

    # Или

    if (10 == 10):
        10 >> out;
    elseif 20 == 20
        20 >> out;
    else:
        30 >> out;
    endif

Цыклы
^^^^^

I have prepeared some different loops e.g.
Я приготовил несколько "разных" цыклов::

    for(0 >> int a; a <= 10; a+1>>a;){
        a >> out;
    }

    0 >> n;
    while n <= 10{
        n >> out;
        n + 1 >> n;
    }


Следующие шаги
==============

.. toctree::
    :maxdepth: 2
    
    advanced_steps
    future_features
